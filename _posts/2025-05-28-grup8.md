---
title: Depth-First Search (DFS)
date: 2025-05-27
categories: [desain dan analisis algoritma]
tags: [belajar]     # TAG names should always be lowercase
description: What is Depth-First Search (DFS)?
---


### What Is Depth-First Search (DFS)? ğŸ”

Alright, letâ€™s dive into one of the OG graph traversal methods: **Depth-First Search**, aka **DFS**. This algorithmâ€™s vibe is all about **going deep**. Instead of exploring all your options at one level (like BFS does), DFS **picks a path and keeps going** until it hits a dead end. Then, it backtracks and tries something else. Think of it like walking into a maze â€” you keep following one hallway until you canâ€™t anymore, then you turn back and try a new one.

DFS is perfect for problems where you need to **explore everything** or go deep into something before worrying about alternatives â€” like searching for cycles, solving puzzles, checking connectivity, or just figuring out if a path exists.

---

### The Stack Trick: How DFS Works ğŸ§ 

Behind the scenes, DFS uses a **stack** â€” either explicitly (you create one in code) or through **recursion**, which uses the systemâ€™s call stack.

* A **stack** is Last-In, First-Out (LIFO), which means the last item you pushed in gets popped out first.
* When DFS visits a node, it goes all the way down one path â€” stacking up calls â€” until it canâ€™t go further.
* Then it â€œunwindsâ€ and explores other paths from earlier steps.

Thatâ€™s why DFS feels like itâ€™s â€œtunnelingâ€ through your graph/tree instead of exploring it floor by floor.

---

### DFS vs. BFS: Same Game, Different Style

Hereâ€™s the showdown:

| Feature        | BFS                                     | DFS                                          |
| -------------- | --------------------------------------- | -------------------------------------------- |
| Strategy       | Wide first                              | Deep first                                   |
| Uses           | Shortest path (unweighted), level order | Cycle detection, path finding, solving mazes |
| Data Structure | Queue                                   | Stack / Recursion                            |
| Memory Usage   | Can get high in wide graphs             | Lower in sparse graphs                       |

So yeah, **BFS is the social butterfly**, visiting everyone nearby first. **DFS is more like a cave explorer**, picking one way and digging deep.

---

### DFS Walkthrough Example ğŸ§­

Letâ€™s say youâ€™ve got this graph:

* A connects to B and C
* B connects to D
  You start at A.

**Hereâ€™s how DFS might roll (recursive):**

1. Visit A
2. Go to B
3. From B, go to D
4. D has no unvisited neighbors â†’ backtrack
5. Go back to A â†’ now visit C
6. C has no new neighbors â†’ done

Visit order? **A â†’ B â†’ D â†’ C**

Notice how we fully finished one branch before even touching C? Thatâ€™s pure DFS energy.

---

### Real-Life Uses (Not Just for Class Projects)

DFS might sound academic, but itâ€™s out here doing real work:

* **Solving puzzles** like mazes or sudoku
* **Checking if a graph is connected** or has cycles
* **Topological sorting** (think: task scheduling, build systems)
* **File system search** (ever used a recursive `find` command? Thatâ€™s DFS!)
* **Web crawling** when you want to go deep into one site before bouncing

Itâ€™s also common in **AI**, **network analysis**, and **compilers** â€” seriously, DFS is all over the place.

---

### Performance Breakdown ğŸ’¡

Hereâ€™s the techy bit:

* **Time Complexity**: O(V + E) â€” where V is the number of vertices and E is the number of edges. Every node and edge gets touched once.
* **Space Complexity**: O(V) â€” for the visited set and recursion stack. Worst case? You go as deep as the number of nodes.

So, DFS is fast and lean â€” unless your graph is super deep and your recursion stack blows up. In languages without tail-call optimization, that can be a problem.


---

### Wrap-Up: Why DFS Is Still a Classic ğŸ†

DFS is one of those algorithms thatâ€™s **simple but powerful**. Itâ€™s not always the best fit (like when shortest paths matter), but when you need to **fully explore**, **detect cycles**, or just **go deep**, DFS is your go-to.

Itâ€™s also a killer intro to recursion and stack-based problem solving â€” the kind of thinking that shows up everywhere in programming and tech.
