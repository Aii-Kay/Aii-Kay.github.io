---
title: Dijkstra's Algorithm
date: 2025-06-3
categories: [desain dan analisis algoritma]
tags: [belajar]     # TAG names should always be lowercase
description: What is Dijkstra's Algorithm?
---


### Whatâ€™s Dijkstraâ€™s Algorithm All About? ğŸš¦

If youâ€™ve ever wondered **how Google Maps finds the fastest route**, or how your internet decides the best path for sending data â€” chances are, **Dijkstraâ€™s Algorithm** is doing the heavy lifting. This bad boy is a classic for finding the **shortest path** between nodes in a **weighted graph**, where each edge has a "cost" â€” like distance, time, or effort.

It was invented by **Edsger Dijkstra** back in the day (1956), but itâ€™s still a go-to algorithm today in stuff like **routing, navigation, and game AI**. Unlike BFS, which just counts steps (edges), Dijkstra **adds up the weights** and gives you the **cheapest trip**, not just the fastest one in terms of hops.

---

### Core Vibe: Greedy but Smart ğŸ§ ğŸ’¸

Dijkstra works using a **greedy approach**, meaning it always goes for the next best move it knows at that moment. It doesnâ€™t look ahead â€” just trusts its gut and moves to the nearest unvisited node with the **lowest total cost** so far.

Sounds risky? Not really â€” because it **keeps updating** the cost of reaching all neighboring nodes. If it later finds a cheaper way to get somewhere, it updates the record.

---

### What You Need to Run Dijkstra in C++ ğŸ› ï¸

Hereâ€™s what youâ€™ll typically use in C++:

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <utility>
#include <limits>
using namespace std;
```

Key structures:

* `vector<vector<pair<int, int>>> graph;` â†’ Adjacency list for weighted edges
* `priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;` â†’ Min-heap to get the node with the shortest known distance
* `vector<int> dist(n, INF);` â†’ To store the shortest distances
* `vector<bool> visited(n, false);` â†’ To keep track of finalized nodes

---

### Step-by-Step: How Dijkstra Rolls ğŸ¬

Hereâ€™s the high-level idea (and youâ€™ll totally see how it maps to C++ code):

1. **Set up**: Distance from source to itself is `0`, others are `INF` (infinity).
2. **Put the source in the priority queue**.
3. While the queue isnâ€™t empty:

   * Pop the node `u` with the smallest known distance.
   * If `u` is already visited, skip it.
   * For every neighbor `v` of `u`:

     * Calculate the cost from `source â†’ u â†’ v`.
     * If itâ€™s cheaper than the current known cost to `v`, update it and push `v` into the queue.

---

### Full C++ Example ğŸ“˜

```cpp
void dijkstra(int source, const vector<vector<pair<int, int>>>& graph, vector<int>& dist) {
    const int INF = numeric_limits<int>::max();
    int n = graph.size();
    dist.assign(n, INF);
    dist[source] = 0;

    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;
    pq.push({0, source});

    while (!pq.empty()) {
        int u = pq.top().second;
        int d = pq.top().first;
        pq.pop();

        if (d > dist[u]) continue;  // Already found a shorter path

        for (auto [v, weight] : graph[u]) {
            if (dist[u] + weight < dist[v]) {
                dist[v] = dist[u] + weight;
                pq.push({dist[v], v});
            }
        }
    }
}
```

---

### Tiny Example ğŸ§®

Say we have:

* A (0) â†’ B (1) with weight 1
* B (1) â†’ C (2) with weight 2
* A (0) â†’ C (2) with weight 5

Dijkstra starts at A:

* It sees B for 1, and C for 5.
* Then it visits B and sees a **better route to C**: 1 (to B) + 2 = **3**, which is better than 5.
* So it updates the shortest path to C as **3**.

And just like that â€” done.

---

### Dijkstra Canâ€™t Handle Negative Drama âŒ

Hereâ€™s a limitation you should know: **Dijkstra doesnâ€™t do negative-weight edges**. Why? Because once it thinks itâ€™s found the shortest path to a node, it wonâ€™t revisit it â€” so if a cheaper path shows up later thanks to a negative edge, it just ignores it. Thatâ€™s a no-go.

If your graph has negative weights, switch to **Bellman-Ford**. Itâ€™s a bit slower but it handles all that drama like a pro.

---

### Where Youâ€™ll See Dijkstra in Real Life ğŸŒ

Dijkstraâ€™s Algorithm is basically **everywhere**:

* ğŸš— **GPS & mapping**: Routes between two places? Yup.
* ğŸŒ **Network routing**: Finding the best path to send data packets
* ğŸ® **Game AI**: NPCs finding paths in terrain
* ğŸ—ï¸ **Logistics**: Optimizing delivery routes and costs

If something needs to **move smartly through a network**, Dijkstraâ€™s probably under the hood making it happen.

---

### Wrap-Up: Dijkstraâ€™s Still the G.O.A.T. ğŸ†

Despite being almost 70 years old, Dijkstraâ€™s Algorithm is still holding it down in modern systems. Itâ€™s **simple, efficient, and powerful** â€” especially when coded right in a language like C++ that gives you full control over your data structures.
