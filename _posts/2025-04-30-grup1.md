---
title: Activity Selection Problem
date: 2025-05-6
categories: [desain dan analisis algoritma]
tags: [belajar]     # TAG names should always be lowercase
description: What is Activity Selection Problem?
---

### So... What's the Deal with Activity Selection?

Alright, hereâ€™s the situation: Youâ€™ve got a bunch of activities to choose from. Each one has a start time and an end time. The catch? You can **only do one thing at a time**. No multitasking hacks here.

Your goal? **Do as many non-overlapping activities as possible.** Like, squeeze the most value out of your day without crashing two events together.

This whole problemâ€™s called the **Activity Selection Problem**, and itâ€™s a classic. Super useful, and turns out, the fix is pretty slick â€” you use something called a **greedy algorithm**.

---

### Where Youâ€™ll See This in Real Life ğŸ“…

This isnâ€™t just textbook noise. It shows up everywhere:

* **Meeting room drama**: Only one room, too many meetings. Wanna fit the max number? This problemâ€™s your BFF.
* **Factory stuff**: One machine, bunch of tasks. You gotta line them up so thereâ€™s zero downtime.
* **Conference planning**: Loads of talks, but you can only go to one at a time? This helps you hit the most without missing out.
* **CPU scheduling**: OS needs to decide what job to run next. This idea helps maximize efficiency.

---

### How the Greedy Algorithm Works ğŸ§ 

Hereâ€™s the step-by-step breakdown (real smooth):

1. **Sort it out**
   Order all activities by their end time â€” earliest first.

2. **Pick the first one**
   Grab the activity that ends the soonest. It gives you the most room to slot in more later.

3. **Loop through the rest**
   If an activity starts **after or when** the last one ended, take it.

4. **Keep it going**
   Rinse and repeat till you hit the end of the list.

---

### Why It Works (Like, Really Works) ğŸ”

The greedy trick â€” picking the thing that ends earliest â€” might sound a bit lazy, but itâ€™s actually smart.
Why? Because it **leaves the most time** for other stuff. If you pick a longer one, youâ€™re eating up future slots. Itâ€™s like picking the shortest line at the supermarket â€” you get out quicker and do more.

Thereâ€™s also a mathy proof behind it (not gonna go full math nerd here), but TL;DR: itâ€™s provably optimal.

---

### ğŸ§‘â€ğŸ’» C++ Code for the Win

Hereâ€™s a simple C++ program that does the job:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

// Define the structure for activity
struct Activity {
    int start, finish;
};

// Custom comparator to sort by finish time
bool compare(Activity a, Activity b) {
    return a.finish < b.finish;
}

void selectActivities(vector<Activity>& activities) {
    sort(activities.begin(), activities.end(), compare);

    cout << "Selected activities:\n";

    int lastFinish = -1;
    for (auto act : activities) {
        if (act.start >= lastFinish) {
            cout << "(" << act.start << ", " << act.finish << ")\n";
            lastFinish = act.finish;
        }
    }
}

int main() {
    vector<Activity> activities = {
        {1, 4}, {3, 5}, {0, 6}, {5, 7}, {8, 9}, {5, 9}
    };

    selectActivities(activities);

    return 0;
}
```

---

### Final Thoughts ğŸ’¬

So yeah â€” this problem's not just a random thing you do for homework. It shows up in all kinds of serious tech, real-world planning, and even your daily chaos.
**The greedy way wins here** â€” just pick the fastest-ending thing, and youâ€™re golden.

If you ever need to look like a genius in your algorithm class or job interview, just remember:
ğŸ‘‰ *â€œDo more by doing less â€” but smarter.â€*
