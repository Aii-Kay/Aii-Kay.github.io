---
title: Kahn's Algorithm
date: 2025-06-3
categories: [desain dan analisis algoritma]
tags: [belajar]     # TAG names should always be lowercase
description: What is Kahn's Algorithm?
---


### Whatâ€™s the Deal with Topological Sorting? ğŸ§©

Before we dive into Kahnâ€™s Algorithm, letâ€™s break down what problem it actually solves. Ever tried organizing a list of tasks where **some jobs need to be done before others**? Like, you gotta put on your socks before your shoes â€” kinda obvious, right? Thatâ€™s what **topological sorting** helps with.

This only works on a special kind of graph called a **DAG** â€” short for **Directed Acyclic Graph**. â€œDirectedâ€ means all connections (aka edges) go one way, like arrows. And â€œacyclicâ€ means there are no loops â€” so you canâ€™t have a situation like task A needing B, B needing C, and C needing A again. Thatâ€™s a recipe for chaos.

---

### Meet Kahnâ€™s Algorithm ğŸ‘¨â€ğŸ«

Kahnâ€™s Algorithm is one of the cleanest and most popular ways to get a **valid topological order** of tasks. It was cooked up by Arthur Kahn back in the 60s (yes, itâ€™s been around that long â€” and it still slaps). The idea is simple but genius: start with tasks that have **no prerequisites**, handle them first, and then peel off layers as other tasks become available.

Itâ€™s a super chill, **step-by-step process** â€” kinda like ticking off a to-do list, where every task unlocks more stuff to do.

---

### How It Works: Letâ€™s Talk In-Degrees ğŸ“Š

The key player in Kahnâ€™s Algorithm is the **in-degree** of each node. In plain terms: itâ€™s how many other tasks need to be finished before you can start this one.

So if a task (node) has **in-degree = 0**, it means itâ€™s totally free to start. These are your â€œgo nowâ€ tasks â€” the ones you throw into your **queue** right away.

As you complete tasks, the dependencies of other tasks shrink, and when their in-degree hits zero â€” boom, theyâ€™re ready to go next.

---

### Step-by-Step: How the Algorithm Goes Down ğŸ§ƒ

Hereâ€™s the flow, broken into chill steps:

1. **Count 'em up**: Go through the whole graph and calculate the in-degree for each node.
2. **Queue it**: Add all nodes with in-degree 0 into a queue. These are your starting points.
3. **Pop and drop**: While the queueâ€™s not empty:

   * Take out (dequeue) a node.
   * Add it to your final list (this is your topological order).
   * For each of its neighbors, lower their in-degree by 1.
   * If any neighbor hits in-degree 0, toss it into the queue.
4. Keep this loop running till your queueâ€™s empty.

---

### Quick Example: Sorting Tasks ğŸ”§

Letâ€™s say youâ€™ve got this setup:

* A â†’ B
* A â†’ C
* B â†’ D
* C â†’ D

**Step-by-step breakdown:**

* In-degrees: A=0, B=1, C=1, D=2
* Queue starts with: `[A]`
* Pop A â†’ Add B and C to queue â†’ `[B, C]`
* Pop B â†’ Lower Dâ€™s in-degree to 1
* Pop C â†’ Lower Dâ€™s in-degree to 0 â†’ Add D â†’ `[D]`
* Pop D â†’ Done!

Final sorted order? `[A, B, C, D]`
(Of course, you might also get `[A, C, B, D]` â€” both are valid topological orders!)

---

### Watch Out for Cycles! ğŸš¨

Hereâ€™s the kicker: if thereâ€™s a **cycle** in your graph, Kahnâ€™s Algorithm **wonâ€™t be able to finish**. Why? Because in a cycle, **every node depends on something else**, so nothing ever gets in-degree 0. Your queue ends up empty, and youâ€™re stuck.

The hack? After running the algorithm, **check the size of your sorted list**. If itâ€™s smaller than the total number of nodes, boom â€” **youâ€™ve got a cycle**. Thatâ€™s how Kahnâ€™s Algorithm doubles as a **cycle detector**.

---

### Where It Actually Gets Used ğŸ¯

This isnâ€™t just academic theory â€” Kahnâ€™s Algorithm is used in tons of real-world scenarios:

* **College course planning**: Making sure students take prerequisites before the big capstone projects.
* **Build systems**: Think `make`, `npm`, or `Maven` â€” compiling files in the right order so your code doesnâ€™t break.
* **Project planning tools**: Managing big task lists where some stuff canâ€™t start until other parts are done.
* **Data pipelines**: Making sure one stepâ€™s output is ready before the next step kicks in (super common in ETL workflows).

Anywhere youâ€™ve got **dependencies** and need to **do things in order**, Kahnâ€™s Algorithm is your guy.

---

### Wrap-Up: Why Kahn's Algorithm Still Rocks ğŸ¤˜

Kahnâ€™s Algorithm is neat, easy to follow, and super practical. It handles **topological sorting** like a boss and even tells you when your setupâ€™s messed up with a cycle.

Itâ€™s a great tool to keep in your algorithmic toolbox, especially when you're working with graphs, dependencies, or anything that needs **order without chaos**.
